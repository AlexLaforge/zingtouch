/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ZingTouch = undefined;

	var _ZingTouch = __webpack_require__(1);

	var _arbiter = __webpack_require__(7);

	//Perform polyfills and setup window listeners.
	var eventNames = ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend'];
	eventNames.forEach(function (val, idx, arr) {
	  document.addEventListener(val, function (event) {
	    (0, _arbiter.arbiter)(event);
	  });
	});

	window.ZingTouch = _ZingTouch.ZingTouch;
	exports.ZingTouch = _ZingTouch.ZingTouch;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ZingTouch = undefined;

	var _state = __webpack_require__(2);

	var _Gesture = __webpack_require__(3);

	var _Tap = __webpack_require__(4);

	var _util = __webpack_require__(5);

	var _Binding = __webpack_require__(6);

	/**
	 * Responsible for creating and destroying bound events, along with appending operations to them.
	 * @type {{Gesture: Gesture, Tap: Tap, bind: ZingTouch.bind, unbind: ZingTouch.unbind}}
	 */
	var ZingTouch = {
	  //Constructors
	  Gesture: _Gesture.Gesture,
	  Tap: _Tap.Tap,

	  /**
	   * Bind an element to a specific registered gesture with multiple function signatures.
	   * bind(element)
	   * bind(element, gesture, handler, [capture])
	   * @param {mixed} element - Either the element object or a qualified string to pass to querySelector
	   * @param {mixed} gesture - Either a string, or a Gesture object.
	   * @param {Function} handler - The function to execute when an event is emitted.
	   * @param {boolean} capture - capture/bubble
	   * @returns {object} - a chainable object that has the same function as bind.
	   */
	  bind: function bind(element, gesture, handler, capture) {
	    element = _util.util.getElement(element);
	    if (element) {
	      //Determine function signature
	      if (!gesture) {
	        return new _Binding.Binding(element);
	      }

	      //Check if gesture is a registered binding.
	      if (_util.util.isValidBinding(gesture)) {
	        var type = typeof gesture === 'string' ? gesture : gesture.type;
	        if (typeof gesture === 'string') {
	          _state.state.addGesture(element, gesture);
	        }

	        element.addEventListener(type, handler, capture);
	      }
	    }
	  },

	  /**
	   * Unbinds an element from either the specified gesture or all if not specified.
	   * @param {mixed} element - Retrieves either the element to remove or a qualified string to pass to querySelector
	   * @param {string} gesture - A String representing the gesture, or the Gesture object used to originally bind.
	   */
	  unbind: function unbind(element, gesture) {},

	  unregister: function unregister() {},

	  register: function register() {}
	};

	exports.ZingTouch = ZingTouch;

/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var registeredBindings = {
	  tap: function tap() {}
	};

	var state = {
	  inputs: [], //Contains current inputs (touches) on the screen
	  currentTarget: null, //The element being targeted for the gesture.
	  currentElement: null,
	  assignees: {}, //Hash map that maps an element to the gestures it is bound to.
	  initialState: [], //Current information about the initial touches.
	  bindings: registeredBindings,
	  /**
	   * Clears the internal state/current gesture in progress.
	   * @mutates inputs to []
	   * @mutates initialState to []
	   * @mutates currentTarget to null
	   */
	  clearState: function clearState() {},

	  addGesture: function addGesture() {}

	};

	exports.state = state;

/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Gesture = function () {
	  function Gesture() {
	    _classCallCheck(this, Gesture);
	  }

	  _createClass(Gesture, [{
	    key: "didOccur",
	    value: function didOccur() {
	      return true;
	    }
	  }]);

	  return Gesture;
	}();

	exports.Gesture = Gesture;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Tap = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Gesture2 = __webpack_require__(3);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Tap = function (_Gesture) {
	  _inherits(Tap, _Gesture);

	  function Tap() {
	    _classCallCheck(this, Tap);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(Tap).call(this));
	  }

	  _createClass(Tap, [{
	    key: 'didOccur',
	    value: function didOccur(ev) {}
	  }]);

	  return Tap;
	}(_Gesture2.Gesture);

	exports.Tap = Tap;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.util = undefined;

	var _state = __webpack_require__(2);

	var _Gesture = __webpack_require__(3);

	var util = {
	  /**
	   * =
	   * @param {mixed} Either a string or an element.
	   * @returns {*} - Returns an element, or null if the parameter was invalid or the element could not be found.
	   */
	  getElement: function getElement(target) {
	    if (target) {
	      if (typeof target === 'string') {
	        return document.querySelector(target);
	      } else if (typeof target.tagName !== 'undefined') {
	        return target;
	      }
	    }

	    return null;
	  },

	  /**
	   * Verifies the the specified gesture is a valid binding. Either its a key in Bindings, or
	   * @param {mixed} binding - Either a string representing a 'registered' gesture or, a Gesture object.
	   * @returns {boolean} - Whether or not the binding is valid.
	   */
	  isValidBinding: function isValidBinding(binding) {
	    return typeof binding === 'string' && Object.keys(_state.state.bindings).indexOf(binding) > -1 || binding instanceof _Gesture.Gesture;
	  }
	};
	exports.util = util;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Binding = undefined;

	var _state = __webpack_require__(2);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Object that contains a map of binding. Created from the ZingTouch.bind() event.
	 * @type {{tap: Bindings.tap}}
	 */

	var Binding = function Binding(element) {
	  _classCallCheck(this, Binding);

	  this.element = element;
	  for (var key in _state.state.bindings) {
	    this[key] = _state.state.bindings;
	  }
	};

	;

	exports.Binding = Binding;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.arbiter = undefined;

	var _state = __webpack_require__(2);

	var _ZingTouch = __webpack_require__(1);

	var _Input = __webpack_require__(8);

	var _interpreter = __webpack_require__(9);

	var _dispatcher = __webpack_require__(10);

	/**
	 * Responsible for :
	 * 1. Receiving all touch events in the window
	 * 2. Determining which gestures are linked to the target element
	 * 3. Negotiating with the Interpreter what event should occur
	 * @param event - The event emitted from the window object.
	 */
	function arbiter(event) {

	  //Convert event information to Input for normalization.
	  _state.state.inputs = [];
	  if (event.touches) {
	    event.touches.forEach(function (val, idx, arr) {
	      _state.state.inputs.push(new _Input.Input(val));
	    });
	  } else {
	    _state.state.inputs.push(new _Input.Input(event));
	  }

	  //If the initial state, store the inputs and target.
	  if (!_state.state.currentTarget) {
	    _state.state.currentTarget = event.target;
	    _state.state.inputs.forEach(function (val, idx, arr) {
	      _state.state.initialState.push(val);
	    });
	  }

	  //TODO : Obtain the appropriate element->gesture relations
	  var oHandler = {};
	  var oData = (0, _interpreter.interpreter)(oHandler);
	  (0, _dispatcher.dispatcher)(oData.type, oData.info);
	  if (oData.terminated) {
	    _state.state.currentTarget = null;
	  }
	}

	exports.arbiter = arbiter;

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Hold important input information and normalizes events across browsers.
	 */

	var Input = function () {
	  function Input(event) {
	    _classCallCheck(this, Input);

	    this.initialTarget = event.target;
	    this.initialEvent = event;
	    this.type = this.normalizeEvent(event.type);
	    this.x = event.x;
	    this.y = event.y;
	  }

	  /**
	   * Normalize mouse and other input types to be touch.
	   * @param {string}
	   * @returns {string} - The type of mouse event
	   */


	  _createClass(Input, [{
	    key: 'normalizeEvent',
	    value: function normalizeEvent(type) {
	      switch (type) {
	        case 'mousedown':
	        case 'touchstart':
	          return 'start';
	          break;
	        case 'mousemove':
	        case 'touchmove':
	          return 'move';
	          break;
	        case 'mouseup':
	        case 'touchend':
	          return 'end';
	          break;
	        default:
	          return null;
	      }
	    }
	  }]);

	  return Input;
	}();

	exports.Input = Input;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 *
	 * @param element - The current target element
	 * @param input - the input
	 * @param Handler
	 * @returns metadata about the gesture
	 */
	function interpreter(element, input, Handler) {
	  console.log('Inside interpreter');
	  return {
	    type: 'swipe',
	    info: {
	      bar: 'foo'
	    },
	    terminated: true
	  };
	}

	exports.interpreter = interpreter;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.dispatcher = undefined;

	var _state = __webpack_require__(2);

	/**
	 * Emits data at the target element and bubbles up from
	 * @param type - The type of event to emit
	 * @param data
	 */
	function dispatcher(type, data) {
	  var newEvent = new CustomEvent(type, {
	    detail: {
	      foo: 'bar'
	    }
	  });
	  emitEvent(_state.state.currentTarget, newEvent);
	}

	/**
	 * Emits the new event recurrsively until the document is reached.
	 * @param target
	 * @param event
	 */
	function emitEvent(target, event) {
	  target.dispatchEvent(event);
	  if (target.parentNode && target.parentNode !== document) {
	    emitEvent(target.parentNode, event);
	  }
	}

	exports.dispatcher = dispatcher;

/***/ }
/******/ ]);